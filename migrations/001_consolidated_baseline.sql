-- Cultural Archiver Database Schema (Consolidated)
-- Extracted on: 2025-01-01T00:00:00.000Z
-- Generated by: manual consolidation of migrations 001-008
-- Version: consolidated-baseline-2025-01-01
--
-- This consolidated schema replaces the original 8 migration files:
-- 001_initial_schema.sql, 002_mvp_schema.sql, 003_consent_audit_schema.sql,
-- 004_add_logbook_location.sql, 005_authentication_tables.sql, 006_add_creators_table.sql,
-- 007_permissions_audit_tables.sql, 008_fix_artwork_coordinates.sql

-- Enable foreign key constraints
PRAGMA foreign_keys = ON;

-- ================================
-- Artwork Types Table
-- Pre-defined categories for public artwork
-- ================================
CREATE TABLE artwork_types (
    id TEXT PRIMARY KEY,
    name TEXT NOT NULL UNIQUE,
    description TEXT,
    created_at TEXT NOT NULL DEFAULT (datetime('now'))
);

-- Index for artwork type lookups
CREATE INDEX idx_artwork_types_name ON artwork_types(name);

-- ================================
-- Artwork Table  
-- Core table for public artwork locations with geospatial data
-- ================================
CREATE TABLE artwork (
    id TEXT PRIMARY KEY,
    lat REAL NOT NULL,
    lon REAL NOT NULL,
    type_id TEXT NOT NULL,
    status TEXT NOT NULL DEFAULT 'pending' CHECK (status IN ('pending', 'approved', 'removed')),
    title TEXT,
    description TEXT,
    user_token TEXT NOT NULL, -- Anonymous UUID token of submitter
    photos TEXT, -- JSON array of R2 URLs
    tags TEXT, -- JSON array of tags
    notes TEXT,
    location_description TEXT,
    created_at TEXT NOT NULL DEFAULT (datetime('now')),
    updated_at TEXT NOT NULL DEFAULT (datetime('now')),
    FOREIGN KEY (type_id) REFERENCES artwork_types(id)
);

-- Indexes for spatial queries and filtering
CREATE INDEX idx_artwork_lat_lon ON artwork(lat, lon);
CREATE INDEX idx_artwork_status ON artwork(status);
CREATE INDEX idx_artwork_type_id ON artwork(type_id);
CREATE INDEX idx_artwork_user_token ON artwork(user_token);
CREATE INDEX idx_artwork_created_at ON artwork(created_at);

-- ================================
-- Logbook Table
-- User submissions and updates for artwork discovery and condition tracking
-- ================================
CREATE TABLE logbook (
    id TEXT PRIMARY KEY,
    artwork_id TEXT, -- NULL for new artwork submissions
    user_token TEXT NOT NULL, -- Anonymous UUID token
    lat REAL,
    lon REAL,
    status TEXT NOT NULL DEFAULT 'pending' CHECK (status IN ('pending', 'approved', 'rejected')),
    notes TEXT,
    photos TEXT, -- JSON array of R2 URLs
    created_at TEXT NOT NULL DEFAULT (datetime('now')),
    updated_at TEXT NOT NULL DEFAULT (datetime('now')),
    FOREIGN KEY (artwork_id) REFERENCES artwork(id) ON DELETE SET NULL
);

-- Indexes for logbook queries
CREATE INDEX idx_logbook_artwork_id ON logbook(artwork_id);
CREATE INDEX idx_logbook_user_token ON logbook(user_token);
CREATE INDEX idx_logbook_status ON logbook(status);
CREATE INDEX idx_logbook_lat_lon ON logbook(lat, lon);
CREATE INDEX idx_logbook_created_at ON logbook(created_at);

-- ================================
-- Tags Table
-- Flexible key-value tagging system for artwork and logbook entries
-- ================================
CREATE TABLE tags (
    id TEXT PRIMARY KEY,
    artwork_id TEXT,
    logbook_id TEXT,
    label TEXT NOT NULL,
    value TEXT,
    created_at TEXT NOT NULL DEFAULT (datetime('now')),
    FOREIGN KEY (artwork_id) REFERENCES artwork(id) ON DELETE CASCADE,
    FOREIGN KEY (logbook_id) REFERENCES logbook(id) ON DELETE CASCADE,
    CHECK ((artwork_id IS NOT NULL AND logbook_id IS NULL) OR 
           (artwork_id IS NULL AND logbook_id IS NOT NULL))
);

-- Indexes for tag queries
CREATE INDEX idx_tags_artwork_id ON tags(artwork_id);
CREATE INDEX idx_tags_logbook_id ON tags(logbook_id);
CREATE INDEX idx_tags_label ON tags(label);

-- ================================
-- Consent Records Table 
-- Persistent consent tracking for legal compliance
-- ================================
CREATE TABLE consent_records (
    id TEXT PRIMARY KEY,
    user_token TEXT NOT NULL,
    consent_version TEXT NOT NULL DEFAULT '1.0.0',
    age_verification BOOLEAN NOT NULL DEFAULT FALSE,
    cc0_licensing BOOLEAN NOT NULL DEFAULT FALSE,
    public_commons BOOLEAN NOT NULL DEFAULT FALSE,
    freedom_of_panorama BOOLEAN NOT NULL DEFAULT FALSE,
    ip_address TEXT,
    user_agent TEXT,
    consented_at TEXT NOT NULL DEFAULT (datetime('now')),
    expires_at TEXT, -- For time-limited consents
    revoked_at TEXT, -- If user revokes consent
    UNIQUE(user_token, consent_version)
);

-- Indexes for consent queries
CREATE INDEX idx_consent_records_user_token ON consent_records(user_token);
CREATE INDEX idx_consent_records_version ON consent_records(consent_version);

-- ================================
-- Photo Metadata Table
-- Detailed photo processing tracking with variants and EXIF data
-- ================================
CREATE TABLE photo_metadata (
    id TEXT PRIMARY KEY,
    photo_url TEXT NOT NULL, -- Original R2 or Cloudflare Images URL
    logbook_entry_id TEXT NOT NULL,
    variant_type TEXT CHECK (variant_type IN ('original', 'thumbnail', '200px', '400px', '800px', '1200px')) DEFAULT 'original',
    file_size INTEGER NOT NULL,
    mime_type TEXT NOT NULL,
    width INTEGER,
    height INTEGER,
    aspect_ratio REAL,
    dominant_color TEXT, -- Hex color for progressive loading
    exif_processed BOOLEAN DEFAULT FALSE,
    permalink_injected BOOLEAN DEFAULT FALSE,
    gps_latitude REAL,
    gps_longitude REAL,
    camera_make TEXT,
    camera_model TEXT,
    taken_at TEXT, -- From EXIF DateTime
    processing_status TEXT CHECK (processing_status IN ('pending', 'processing', 'completed', 'failed')) DEFAULT 'pending',
    cloudflare_image_id TEXT, -- For Cloudflare Images integration
    created_at TEXT NOT NULL DEFAULT (datetime('now')),
    FOREIGN KEY (logbook_entry_id) REFERENCES logbook(id) ON DELETE CASCADE
);

-- Indexes for photo metadata queries
CREATE INDEX idx_photo_metadata_logbook_entry ON photo_metadata(logbook_entry_id);
CREATE INDEX idx_photo_metadata_variant_type ON photo_metadata(variant_type);
CREATE INDEX idx_photo_metadata_processing_status ON photo_metadata(processing_status);

-- ================================
-- Users Table
-- Core table for authenticated users with UUID claiming
-- ================================
CREATE TABLE users (
    uuid TEXT PRIMARY KEY,  -- User's claimed UUID (same as anonymous token)
    email TEXT NOT NULL UNIQUE,  -- User's email address
    display_name TEXT,  -- Optional display name
    role TEXT NOT NULL DEFAULT 'user' CHECK (role IN ('user', 'moderator', 'admin')),
    created_at TEXT NOT NULL DEFAULT (datetime('now')),  -- Account creation timestamp
    updated_at TEXT NOT NULL DEFAULT (datetime('now')),
    last_login TEXT,  -- Last login timestamp (NULL for new accounts)
    email_verified_at TEXT,  -- When email was verified via magic link (NULL if not verified)
    status TEXT NOT NULL DEFAULT 'active' CHECK (status IN ('active', 'suspended')),  -- Account status
    CONSTRAINT users_uuid_format CHECK (uuid LIKE '________-____-4___-____-____________')  -- UUID v4 format validation
);

-- Indexes for user queries
CREATE INDEX idx_users_email ON users(email);
CREATE INDEX idx_users_role ON users(role);
CREATE INDEX idx_users_status ON users(status);
CREATE INDEX idx_users_last_login ON users(last_login);

-- ================================
-- Magic Links Table
-- Secure tokens for email-based authentication
-- ================================
CREATE TABLE magic_links (
    token TEXT PRIMARY KEY,  -- Cryptographically secure token (32+ bytes)
    email TEXT NOT NULL,  -- Target email address
    user_uuid TEXT,  -- Associated user UUID (NULL for new account creation)
    created_at TEXT NOT NULL DEFAULT (datetime('now')),  -- Token generation timestamp
    expires_at TEXT NOT NULL,  -- Token expiration (1 hour from creation)
    used_at TEXT,  -- When token was consumed (NULL if not used)
    ip_address TEXT,  -- IP address that requested the magic link
    user_agent TEXT,  -- User agent that requested the magic link
    is_signup BOOLEAN NOT NULL DEFAULT FALSE,  -- TRUE for account creation, FALSE for login
    FOREIGN KEY (user_uuid) REFERENCES users(uuid) ON DELETE CASCADE,
    CONSTRAINT magic_link_token_length CHECK (length(token) >= 64),  -- Min 32 bytes = 64 hex chars
    CONSTRAINT magic_link_expires_valid CHECK (expires_at > created_at),
    CONSTRAINT magic_link_used_valid CHECK (used_at IS NULL OR used_at >= created_at)
);

-- Indexes for magic link queries and cleanup
CREATE INDEX idx_magic_links_email ON magic_links(email);
CREATE INDEX idx_magic_links_expires_at ON magic_links(expires_at);
CREATE INDEX idx_magic_links_used_at ON magic_links(used_at);
CREATE INDEX idx_magic_links_created_at ON magic_links(created_at);

-- ================================
-- Rate Limiting Table
-- Request rate limiting and abuse prevention
-- ================================
CREATE TABLE rate_limiting (
    identifier TEXT NOT NULL,           -- Email address or IP address
    identifier_type TEXT NOT NULL CHECK (identifier_type IN ('email', 'ip')),
    request_count INTEGER NOT NULL DEFAULT 0,      -- Requests in current window
    window_start TEXT NOT NULL,         -- Rate limit window start timestamp
    last_request_at TEXT NOT NULL,      -- Last request timestamp
    blocked_until TEXT,                 -- Block expiration time (NULL if not blocked)
    PRIMARY KEY (identifier, identifier_type)
);

-- Indexes for rate limit queries
CREATE INDEX idx_rate_limiting_blocked_until ON rate_limiting(blocked_until);
CREATE INDEX idx_rate_limiting_window_start ON rate_limiting(window_start);

-- ================================
-- Auth Sessions Table
-- User session management
-- ================================
CREATE TABLE auth_sessions (
    id TEXT PRIMARY KEY,
    user_uuid TEXT NOT NULL,
    created_at TEXT NOT NULL DEFAULT (datetime('now')),
    last_used_at TEXT NOT NULL DEFAULT (datetime('now')),
    expires_at TEXT, -- NULL for permanent sessions
    ip_address TEXT,
    user_agent TEXT,
    is_active INTEGER NOT NULL DEFAULT 1,
    FOREIGN KEY (user_uuid) REFERENCES users(uuid) ON DELETE CASCADE
);

-- Indexes for session queries
CREATE INDEX idx_auth_sessions_user_uuid ON auth_sessions(user_uuid);
CREATE INDEX idx_auth_sessions_expires_at ON auth_sessions(expires_at);
CREATE INDEX idx_auth_sessions_last_used_at ON auth_sessions(last_used_at);

-- ================================
-- Creators Table
-- Individual artists and creators who make artwork
-- ================================
CREATE TABLE creators (
    id TEXT PRIMARY KEY,
    name TEXT NOT NULL,
    bio TEXT,
    created_at TEXT NOT NULL DEFAULT (datetime('now'))
);

-- Index for creator name searches
CREATE INDEX idx_creators_name ON creators(name);

-- ================================
-- Artwork Creators Junction Table
-- Many-to-many relationship between artworks and creators
-- ================================
CREATE TABLE artwork_creators (
    id TEXT PRIMARY KEY,
    artwork_id TEXT NOT NULL,
    creator_id TEXT NOT NULL,
    role TEXT DEFAULT 'artist', -- artist, designer, architect, etc.
    created_at TEXT NOT NULL DEFAULT (datetime('now')),
    FOREIGN KEY (artwork_id) REFERENCES artwork(id) ON DELETE CASCADE,
    FOREIGN KEY (creator_id) REFERENCES creators(id) ON DELETE CASCADE
);

-- Indexes for relationship queries
CREATE INDEX idx_artwork_creators_artwork_id ON artwork_creators(artwork_id);
CREATE INDEX idx_artwork_creators_creator_id ON artwork_creators(creator_id);
CREATE UNIQUE INDEX idx_artwork_creators_unique ON artwork_creators(artwork_id, creator_id, role);

-- ================================
-- User Permissions Table
-- Database-backed role management system
-- ================================
CREATE TABLE user_permissions (
    id TEXT PRIMARY KEY,
    user_uuid TEXT NOT NULL,
    permission TEXT NOT NULL CHECK (permission IN ('moderator', 'admin')),
    granted_by TEXT NOT NULL, -- admin user_uuid who granted this permission
    granted_at TEXT NOT NULL DEFAULT (datetime('now')),
    revoked_at TEXT NULL,
    revoked_by TEXT NULL,
    is_active INTEGER NOT NULL DEFAULT 1 CHECK (is_active IN (0, 1)),
    notes TEXT, -- reason for granting/revoking
    FOREIGN KEY (user_uuid) REFERENCES users(uuid) ON DELETE CASCADE,
    FOREIGN KEY (granted_by) REFERENCES users(uuid) ON DELETE SET NULL,
    FOREIGN KEY (revoked_by) REFERENCES users(uuid) ON DELETE SET NULL
);

-- Indexes for permission lookups
CREATE UNIQUE INDEX idx_user_permissions_active ON user_permissions(user_uuid, permission) WHERE is_active = 1;
CREATE INDEX idx_user_permissions_user ON user_permissions(user_uuid);
CREATE INDEX idx_user_permissions_permission ON user_permissions(permission);
CREATE INDEX idx_user_permissions_granted_by ON user_permissions(granted_by);

-- ================================
-- Moderation Table
-- Comprehensive logging of all moderation actions
-- ================================
CREATE TABLE moderation (
    id TEXT PRIMARY KEY,
    artwork_id TEXT, -- artwork being moderated
    logbook_id TEXT, -- logbook entry being moderated
    moderator_uuid TEXT NOT NULL, -- who made the decision
    action TEXT NOT NULL CHECK (action IN ('approve', 'reject', 'flag', 'unflag', 'delete', 'restore')),
    reason TEXT, -- reason for action
    notes TEXT, -- additional notes
    metadata TEXT, -- JSON: IP, user agent, session info
    status TEXT NOT NULL DEFAULT 'pending' CHECK (status IN ('pending', 'completed', 'cancelled')),
    created_at TEXT NOT NULL DEFAULT (datetime('now')),
    updated_at TEXT NOT NULL DEFAULT (datetime('now')),
    FOREIGN KEY (artwork_id) REFERENCES artwork(id) ON DELETE CASCADE,
    FOREIGN KEY (logbook_id) REFERENCES logbook(id) ON DELETE CASCADE,
    FOREIGN KEY (moderator_uuid) REFERENCES users(uuid) ON DELETE SET NULL,
    CHECK ((artwork_id IS NOT NULL AND logbook_id IS NULL) OR 
           (artwork_id IS NULL AND logbook_id IS NOT NULL))
);

-- Indexes for moderation queries
CREATE INDEX idx_moderation_artwork_id ON moderation(artwork_id);
CREATE INDEX idx_moderation_logbook_id ON moderation(logbook_id);
CREATE INDEX idx_moderation_moderator_uuid ON moderation(moderator_uuid);
CREATE INDEX idx_moderation_action ON moderation(action);
CREATE INDEX idx_moderation_status ON moderation(status);
CREATE INDEX idx_moderation_created_at ON moderation(created_at);

-- ================================
-- Admin Audit Log Table
-- Comprehensive logging of all administrative actions
-- ================================
CREATE TABLE admin_audit_log (
    id TEXT PRIMARY KEY,
    admin_uuid TEXT NOT NULL,
    target_uuid TEXT, -- user being acted upon
    action TEXT NOT NULL,
    resource_type TEXT NOT NULL, -- user, artwork, logbook, etc.
    resource_id TEXT, -- ID of the resource
    old_values TEXT, -- JSON of changed fields before
    new_values TEXT, -- JSON of changed fields after
    ip_address TEXT,
    user_agent TEXT,
    created_at TEXT NOT NULL DEFAULT (datetime('now')),
    FOREIGN KEY (admin_uuid) REFERENCES users(uuid) ON DELETE SET NULL,
    FOREIGN KEY (target_uuid) REFERENCES users(uuid) ON DELETE SET NULL
);

-- Indexes for audit log queries
CREATE INDEX idx_admin_audit_log_admin_uuid ON admin_audit_log(admin_uuid);
CREATE INDEX idx_admin_audit_log_target_uuid ON admin_audit_log(target_uuid);
CREATE INDEX idx_admin_audit_log_action ON admin_audit_log(action);
CREATE INDEX idx_admin_audit_log_resource_type ON admin_audit_log(resource_type);
CREATE INDEX idx_admin_audit_log_created_at ON admin_audit_log(created_at);

-- ================================
-- Triggers for automatic updated_at timestamps
-- ================================

-- Trigger for artwork updated_at
CREATE TRIGGER trigger_artwork_updated_at
    AFTER UPDATE ON artwork
    FOR EACH ROW
BEGIN
    UPDATE artwork SET updated_at = datetime('now') WHERE id = NEW.id;
END;

-- Trigger for logbook updated_at
CREATE TRIGGER trigger_logbook_updated_at
    AFTER UPDATE ON logbook
    FOR EACH ROW
BEGIN
    UPDATE logbook SET updated_at = datetime('now') WHERE id = NEW.id;
END;

-- Trigger for users updated_at
CREATE TRIGGER trigger_users_updated_at
    AFTER UPDATE ON users
    FOR EACH ROW
BEGIN
    UPDATE users SET updated_at = datetime('now') WHERE uuid = NEW.uuid;
END;

-- Trigger for moderation updated_at
CREATE TRIGGER trigger_moderation_updated_at
    AFTER UPDATE ON moderation
    FOR EACH ROW
BEGIN
    UPDATE moderation SET updated_at = datetime('now') WHERE id = NEW.id;
END;